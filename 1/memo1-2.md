
# 1.2 手続きと処理が生成するもの

https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html#%_sec_1.2  

考察を経ての結果の可視化は、真のプログラマにとって重要な事である.
何処で何の手続きが、望む結果を受け継ぐか。

# 1.2.1 反復と再帰

nの階乗.
```
n! x :: let x :
  1 => 1
  n => n * (n-1)!
```

漸化モデル: 単純な漸化式をそのまま表現することも出来るが、同時に、  
置換モデル: 1から数え始めてxに達するまでの積として考えることも出来る。  

2つの手続きの過程を比較すると大いに異なる。
漸化モデルでは鎖のように定義された演算子の記号が鎖のように積み重なっていて(`recursive process`)、解釈するものに再び元の場所に戻る事を要求する。
それぞれの行の長さは、掛け算は何回目なのかに比例しており、線の長さが回数に比例する時、線形再帰手続き(`linear recursive process`)と 呼ばれる。

対して置換モデルでは伸びも縮みもしない。それぞれの手順毎にすべてにn関して,現在の計算された値,手順の回数を数えるもの,手順の回数を数えるものの最大値, が示されている。 これを、反復処理(`iterative process`) と命名し、現状ではこれは同時に値の状態を示している。


scehme の場合では積み重なるように書かれた手続きであろうと最適化される。


# 1.2.2 木構造の再帰

フィボナッチ数列について、漸化式を木構造の再帰としてそのまま実装すると 巨大な値を入れた時に対応出来ない。 繰り返しの再帰式に変換すると巨大な値も計算できる。  
 数値よりも構造のデータとして木構造の再帰を扱うと良く、プログラマとしても設計を行い易い。
 
最初の例は2つ目の例より効率が悪く、簡単で、Lispに漸化式を翻訳しただけである。

### コイン交換

(n::$) を ([m1, m2, m3...]::[$]) のそれぞれ任意回ずつの総和としたときの、パターンは幾つか?


# 1.2.3 成長の順序
n を問題の大きさとし、R(n)を問題が要求する処理の大きさとする。
平方根のnならば精度であり、行列の掛け算のnならば行列の行数だろう。
R(n)は内部記憶装置のレジスタをどれだけ占領するかであって、凡その計算機が実行した処理の数であって、その他のr諸々である。  

例えば1.2.1の階乗についてnに対し、再帰的に書かれた例では  
実行回数 Θ(n) 、かつ 空間 Θ(n)  
に対し、繰り返しを用いて書かれた例では、  
実行回数 Θ(n) 、に対して 空間 Θ(1) で一定。  

Θ(\1) の \1 は入力の中の最大の指数。


# 1.2.4 累乗
定義を元にすると、
```
b^n = b*b^(n-1)
b^0 = 1
```
繰り返しの形に変換した時の計算量はΘ(n)で空間量はΘ(1)である。

累乗について観察すると、
```
b^2 = b*b
b^4 = b^2*b^2
b^8 = b^4*b^4
```
これを元にして2を底としたΘ(log n)の累乗を実装できる。
```
b^n = (b^(n/2))^2  if n is even
b^n = b*b^(n-1)    if n is odd
```

nが大きくなるに従って n と log n の差は大きくなっていき、n=1000の時も、累乗での掛け算の回数は 14 である。

- ex1.16 は底と状態を間違えて手間取った。カンニング。
- ex1.19 2回目から見た1回目への微分を行う。納得いかない。実質的なカンニング。  







